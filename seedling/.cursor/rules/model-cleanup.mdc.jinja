---
description: "Removes redundant Pydantic validators duplicated by field constraints"
globs:
  - "src/**/*.py"
  - "models/**/*.py"
alwaysApply: false
---

# Model Cleanup: Pydantic Validators

## ðŸŽ¯ Goal

Remove unnecessary `@field_validator` methods that duplicate existing Pydantic field constraints. Retain validators only when they implement cross-field logic, transformations, or unique business rules.

---

## ðŸ”Ž What to Look For

### Remove if the validator simply enforces:
- `v < 0` and the field has `ge=0.0`
- `v > max` and the field has `le=max`
- Any range check already covered by `ge`, `le`, `gt`, or `lt`

```python
# REMOVE â€” Redundant with ge=0.0
@field_validator("start_time")
def validate_start_time(cls, v):
    if v < 0:
        raise ValueError("Must be non-negative")
    return v

# REMOVE â€” Redundant with le=1.0
@field_validator("opacity")
def validate_opacity(cls, v):
    if v > 1.0:
        raise ValueError("Cannot exceed 1.0")
    return v
```

### **Keep Validators That Provide Unique Value**

**Keep if the validator:**
- Does cross-field validation (e.g., end_time > start_time)
- Validates against a specific list of values
- Provides complex business logic
- Transforms data (like converting empty strings to None)
- Performs calculations or derived validations

**Examples to keep:**
```python
# KEEP - cross-field validation
@field_validator("end_time")
def validate_end_time(cls, v, info):
    start_time = info.data.get("start_time")
    if v is not None and start_time is not None and v <= start_time:
        raise ValueError("End time must be after start time")
    return v

# KEEP - validates against specific list
@field_validator("easing")
def validate_easing(cls, v):
    valid_easings = ["linear", "ease_in", "ease_out"]
    if v not in valid_easings:
        raise ValueError(f"Unsupported easing: {v}")
    return v
```

ðŸ§ª Implementation Steps
Identify validators that replicate field-level constraints

Remove them and update tests accordingly

Retain test coverage for edge cases and logic that remains

Confirm all tests pass

ðŸ§  Common Pydantic Constraints
Constraint	Meaning
ge=0.0	â‰¥ 0
le=1.0	â‰¤ 1
ge=1	â‰¥ 1
gt=0	> 0
lt=100	< 100

âœ… Benefits
- Cleaner, more idiomatic Pydantic code
- Fewer custom methods to maintain
- Performance and consistency improvements
- Simpler test surface

ðŸ“ˆ Success Criteria
- All tests pass
- No loss in functionality
- 80%+ test coverage retained
- Redundant methods removed
- Unique logic preserved

## Example Before/After

**Before:**
```python
class MyModel(BaseModel):
    value: float = Field(ge=0.0, le=1.0)

    @field_validator("value")
    def validate_value(cls, v):
        if v < 0:
            raise ValueError("Value cannot be negative")
        if v > 1:
            raise ValueError("Value cannot exceed 1")
        return v
```

**After:**
```python
class MyModel(BaseModel):
    value: float = Field(ge=0.0, le=1.0)
    # Removed redundant validator - Pydantic handles validation
```

Apply this analysis to the provided model file and remove any duplicated validators while preserving unique business logic. 